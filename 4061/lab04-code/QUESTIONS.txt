                           __________________

                            LAB 04 QUESTIONS
                           __________________


- Name: (FILL THIS in)
- NetID: (THE kauf0095 IN kauf0095@umn.edu)

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete Lab01.


PROBLEM 1 `parent_listen.c'
===========================

A
~

  Compile and run the program in `parent_listen.c'. Show it's output
  below.

  Child wrote 17 bytes
  Parent read 17 bytes
  Child said: 'Send $$$ please!'



B
~

  Consider the call to pipe(). Do some research to figure out what a
  pipe does and explain in a few sentences.

	Allows the ability to for child processes to be able to write to characters to the parent. The
	parent then can read the output in using read() and the child can write using write();

C
~

  Observe the calls to read() and write(). Their meaning should be
  self-evident (read and write data) but the parameters to these
  functions are interesting. Do some reading and explain the 3
  parameters to each of them. Also explain their return value.

	read(fd, buf, count) reads froms the file descriptor up count bytes and puts the bytes into
	buf. The return value indicates the amount of bytes read. 

	write(fd, buf, count) writes characters from buf up co count bytes into the file descriptor. The number of bytes writen is
	returned.



D


  If you run the program a number of times, you may see output in
  different orders: the child may report writing data before the parent
  has read it.  Adjust the position of the wait() call to guarantee that
  the order is always
  - Child wrote
  - Parent read
  - Child said
  Paste your code below.

  Already is in a  valid position, no change is needed


PROBLEM 2 `capture_stdout.c'
============================

A
~

  Compile and run the program in `capture_stdout.c'. Show its output.

	Process 25426 Piping
	25426 Read from the my_pipe
	25426 Read: '25426 In the pipe, five by five'


B
~

  The calls `dup()' and `dup2()' are used in this program to manipulate
  file descriptors. Explain the effects of the lines below.
  ,----
  | int stdout_bak = dup(STDOUT_FILENO);
  | dup2(my_pipe[PWRITE], STDOUT_FILENO);
  | ...
  | dup2(stdout_bak, STDOUT_FILENO);
  `----
	The first line copies the stdout into the stdou_bak variable.
	second line copies the contents of mu_pipe[PWRITE] into STDOUT_FILENO.
	3rd line restores the old stdout that was stored in stdout_bak back 

C
~

  The use of `printf()' normally puts output directly on the
  screen. Explain why the statement
  ,----
  | printf("%d In the pipe, five by five",
  |        getpid());
  `----
  does not print to screen as usual.

	Since all stdout is being written to the to write arg of the pipe until the old stdout is restored.
	It isn't being outputted until the contents of pipe is outputted. 

D
~

  Modify the code so that the `In the pipe...' expression is printed by
  a child process.
  - Add a `fork()' AFTER `dup2()' redirects standard output but before
    the print
  - Add an `if()' to distinguish between parent and child
  - The child should print then exit
  - The parent should restore stdout then read from the pipe
  - Add a `wait()' to guarantee the parent waits for the child to
    complete prior to reading from the pipe
  Paste your completed code below

int main(){                                                                                                                                                                                                 
  setvbuf(stdout, NULL, _IONBF, 0);        // Turn off I/O buffering                
                                                                                    
  printf("Process %d Piping\n",getpid());                                           
  int my_pipe[2];                                                                   
  pipe(my_pipe);                                                                    
                                                                                    
  int stdout_bak = dup(STDOUT_FILENO);     // Duplicate stdout so it can be restored later
  dup2(my_pipe[PWRITE], STDOUT_FILENO);    // Redirect stdout to pipe               
  pid_t child_pid = fork();                                                         
                                                                                    
  if (child_pid == 0) {                                                             
  	dup2(stdout_bak, STDOUT_FILENO);         // Restore output so print is sent to stdout.
    printf("%d In the pipe, five by five", getpid());                               
    _exit(3);                                                                       
  }                                                                                 
  wait(NULL);                                                                       
  close(my_pipe[PWRITE]);                  // Close the write end of the pipe    
                                                                                    
  dup2(stdout_bak, STDOUT_FILENO);         // Restore stdout: redirect to backed up fd
                                                                                    
  printf("%d Read from the my_pipe\n",getpid());                                    
  char buf[2048];                                                                   
  int bytes_read = read(my_pipe[PREAD], buf, 2048);                                 
                                                                                    
  buf[bytes_read] = '\0';                  // Not null-terminated by default, append '\0'
  close(my_pipe[PREAD]);                   // Close read end                        
  printf("%d Read: '%s'\n",getpid(),buf);  // Show earlier output                   
                                                                                    
  return 0;                                                                         
}
